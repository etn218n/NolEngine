#define vertex
#version 330 core

layout(location = 0) in vec3 Position;
layout(location = 1) in vec3 Normal;
layout(location = 2) in vec2 TexCoord;

out vec3 VertexNormal;
out vec2 VertexTexCoord;
out vec3 FragmentPosition;

uniform mat4 uModel;
uniform mat4 uViewProjection;

void main()
{
	gl_Position    = uViewProjection * uModel * vec4(Position, 1.0);
	VertexTexCoord = TexCoord;
	VertexNormal   = mat3(transpose(inverse(uModel))) * Normal;  

	FragmentPosition = vec3(uModel* vec4(Position, 1.0f));
}

#define fragment
#version 330 core

struct Material 
{
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
}; 
  
struct Light 
{
	int type;
    vec3 position;
	vec3 direction;
    vec3 color;

	float cutoff;
	float outercutoff;
	float constant;
    float linear;
    float quadratic;
};

in vec3 VertexNormal;
in vec2 VertexTexCoord;
in vec3 FragmentPosition;

out vec4 FragColor;

uniform Light[10] uLight;
uniform int uNumberofLights;
uniform Material uMaterial;
uniform sampler2D uTexture0;
uniform vec3 uCameraPosition;

vec3 DirectionalLighting(Light light, vec3 normalVector);
vec3 SpotLighting(Light light, vec3 normalVector);
vec3 PointLighting(Light light, vec3 normalVector);

void main()
{
	vec3 normalVector = normalize(VertexNormal);

	vec3 result = vec3(0.0f, 0.0f, 0.0f);

	for (int i = 0; i < uNumberofLights; i++)
	{
		if (uLight[i].type == 0) // Directional Light
			result += DirectionalLighting(uLight[i], normalVector);
		else if(uLight[i].type == 1) // Point Light
			result += PointLighting(uLight[i], normalVector);
		else if(uLight[i].type == 2) // Spot Light
			result += SpotLighting(uLight[i], normalVector);
	}

	FragColor = vec4(result, 1.0f) * texture(uTexture0, VertexTexCoord);
}

vec3 DirectionalLighting(Light light, vec3 normalVector)
{
	vec3 lightDirection = normalize(-light.direction);  
	float diffuseIntensity = max(dot(normalVector, lightDirection), 0);

	vec3 reflectDirection = reflect(-lightDirection, normalVector);
	float specularIntensity = pow(max(dot(reflectDirection, normalize(uCameraPosition - FragmentPosition)), 0), uMaterial.shininess);

	vec3 ambient  = light.color * uMaterial.ambient;
	vec3 diffuse  = light.color * uMaterial.diffuse  * diffuseIntensity;
	vec3 specular = light.color * uMaterial.specular * specularIntensity;
	
	return (ambient + specular + diffuse);
}

vec3 PointLighting(Light light, vec3 normalVector)
{
	vec3 lightDirection = normalize(light.position - FragmentPosition);  
	float diffuseIntensity = max(dot(normalVector, lightDirection), 0) + 0.1f;

	vec3 reflectDirection = reflect(-lightDirection, normalVector);
	float specularIntensity = pow(max(dot(reflectDirection, normalize(uCameraPosition - FragmentPosition)), 0), uMaterial.shininess);

	float distance    = length(light.position - FragmentPosition);
	float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    

	vec3 ambient  = light.color * uMaterial.ambient;
	vec3 diffuse  = light.color * uMaterial.diffuse  * diffuseIntensity;
	vec3 specular = light.color * uMaterial.specular * specularIntensity;

	return (ambient + specular + diffuse) * attenuation;
}

vec3 SpotLighting(Light light, vec3 normalVector)
{
	vec3 lightDirection = normalize(light.position - FragmentPosition);  
	float diffuseIntensity = max(dot(normalVector, lightDirection), 0) + 0.1f;

	vec3 reflectDirection = reflect(-lightDirection, normalVector);
	float specularIntensity = pow(max(dot(reflectDirection, normalize(uCameraPosition - FragmentPosition)), 0), uMaterial.shininess);

	float distance    = length(light.position - FragmentPosition);
	float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    

	vec3 ambient  = light.color * uMaterial.ambient;
	vec3 diffuse  = light.color * uMaterial.diffuse  * diffuseIntensity;
	vec3 specular = light.color * uMaterial.specular * specularIntensity;
		
	float theta = dot(lightDirection, normalize(-light.direction)); 
	float epsilon = (light.cutoff - light.outercutoff);
	float intensity = clamp((theta - light.outercutoff) / epsilon, 0.0, 1.0);
	diffuse  *= intensity;
	specular *= intensity;

	return (ambient + specular + diffuse) * attenuation;
}

